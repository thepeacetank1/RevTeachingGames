<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Parabola Hoops! – Enhanced</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0;
        padding-top: 10px;
        background: linear-gradient(
          to bottom,
          #87ceeb 0%,
          #add8e6 100%
        );
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana,
          sans-serif;
      }
      h3 {
        color: #4682b4;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
      }
      #score {
        font-size: 1.4em;
        color: #fff;
        background: rgba(0, 0, 0, 0.5);
        padding: 6px 12px;
        border-radius: 8px;
        margin-bottom: 8px;
      }
      #dynamicEquationDisplay {
        background: rgba(255, 255, 255, 0.85);
        padding: 6px 12px;
        border-radius: 6px;
        font-family: 'Courier New', monospace;
        margin-bottom: 8px;
      }
      #gameContainer {
        display: flex;
        flex-direction: row;
        gap: 20px;
        width: 95%;
        max-width: 1200px;
        justify-content: center;
      }
      #canvasWrapper {
        position: relative;
        flex-shrink: 1;
        width: 70%;       /* same as your old gameCanvas width */
        max-width: 800px;
        aspect-ratio: 800 / 500;
      }
      #gameCanvas {
        position: relative;
        z-index: 1;
        width: 100%;
        height: auto;
      }
      #inputControls {
        position: relative;
        background: rgba(255, 255, 255, 0.9);
        padding: 15px;
        border-radius: 12px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
        width: 200px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      #inputControls label {
        font-size: 0.95em;
        font-weight: bold;
      }
      #inputControls input,
      #inputControls select {
        padding: 6px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-family: monospace;
        width: 100%;
        box-sizing: border-box;
      }
      #shootButton {
        padding: 10px;
        background: linear-gradient(
          to bottom,
          #5cb85c,
          #4cae4c
        );
        color: #fff;
        font-weight: bold;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: background 0.2s;
      }
      #shootButton:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      #message {
        position: absolute;
        top: 45%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.9);
        padding: 15px 30px;
        font-size: 2em;
        font-weight: bold;
        border-radius: 10px;
        display: none;
        z-index: 10;
      }
      /* Confetti */
      #confettiCanvas {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 2;
        width: 100%;
        height: auto;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <h3>Parabola Hoops! – Enhanced</h3>
    <div id="score">Score: 0 | High: 0</div>
    <div id="dynamicEquationDisplay">Path: …</div>
    <div id="gameContainer">
      <div id="canvasWrapper">
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        <canvas id="confettiCanvas" width="800" height="500"></canvas>
      </div>
      <div id="inputControls">…</div>
    </div>

      <div id="inputControls">
        <label for="envSelect">Environment (g):</label>
        <select id="envSelect">
          <option value="earth">Earth (9.8)</option>
          <option value="moon">Moon (1.6)</option>
          <option value="mars">Mars (3.7)</option>
          <option value="custom">Custom</option>
        </select>
        <input
          type="number"
          id="customG"
          placeholder="g = …"
          step="0.1"
          style="display:none"
        />
        <label for="initialVx">v<span style="font-size:0.8em;"
            >x₀</span> (m/s):</label>
        <input
          type="number"
          id="initialVx"
          step="0.1"
          value="10.0"
        />
        <label for="initialVy">v<span style="font-size:0.8em;"
            >y₀</span> (m/s):</label>
        <input
          type="number"
          id="initialVy"
          step="0.1"
          value="18.0"
        />
        <button id="shootButton">Shoot!</button>
        <hr />
        <label>Guess A, B in:</label>
        <div style="font-family:monospace; font-size:0.9em;">
          y = A(x–x₀)² + B(x–x₀)+ y₀
        </div>
        <input
          type="number"
          id="guessA"
          step="0.0001"
          placeholder="A"
        />
        <input
          type="number"
          id="guessB"
          step="0.001"
          placeholder="B"
        />
        <button id="checkGuessBtn">Check</button>
      </div>
    </div>
    <div id="message">SWISH!</div>

    <!-- Sound effects -->
    <audio id="swishSound" src="swish.mp3"></audio>
    <audio id="missSound" src="miss.mp3"></audio>

    <script>
      // --- SETUP ---
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const confCanvas = document.getElementById('confettiCanvas');
      const cctx = confCanvas.getContext('2d');
      const scoreEl = document.getElementById('score');
      const msgEl = document.getElementById('message');
      const envSelect = document.getElementById('envSelect');
      const customG = document.getElementById('customG');
      const vxInput = document.getElementById('initialVx');
      const vyInput = document.getElementById('initialVy');
      const shootBtn = document.getElementById('shootButton');
      const dynEq = document.getElementById(
        'dynamicEquationDisplay'
      );
      const guessA = document.getElementById('guessA');
      const guessB = document.getElementById('guessB');
      const checkGuessBtn = document.getElementById(
        'checkGuessBtn'
      );
      const swishSnd = document.getElementById('swishSound');
      const missSnd = document.getElementById('missSound');
      let CANVAS_W = canvas.width,
        CANVAS_H = canvas.height;
      let START_X = 40,
        START_Y = CANVAS_H - 40;
      let BALL_RADIUS = 10;
      let BACKBOARD_W = 8,
        BACKBOARD_H = 70,
        HOOP_W = 45,
        HOOP_TH = 6;
      let BOUNCE_X = 0.6,
        BOUNCE_Y = 0.7;
      let trail = [],
        MAX_TRAIL = 20;
      let arrowPoints = [];
      let confetti = [];
      let score = 0,
        highScore = +localStorage.getItem(
          'physicsHoopsHighScore'
        ) || 0;
      let ball = {
        x: START_X,
        y: START_Y,
        vx: 0,
        vy: 0,
        color: '#ff8c00'
      };
      let hoopX = 0,
        hoopY = 0;
      let isShooting = false,
        justScored = false,
        animId = null;

      // GRAVITY HANDLING
      function getG() {
        const env = envSelect.value;
        if (env === 'earth') return 9.8 / 39.2; // scale to canvas
        if (env === 'moon') return 1.6 / 39.2;
        if (env === 'mars') return 3.7 / 39.2;
        const v = parseFloat(customG.value);
        return isNaN(v) ? 9.8 / 39.2 : v / 39.2;
      }
      envSelect.addEventListener('change', () => {
        if (envSelect.value === 'custom') {
          customG.style.display = 'block';
        } else customG.style.display = 'none';
        drawGame();
      });
      customG.addEventListener('input', drawGame);

      // --- HOOP RANDOMIZER ---
      const MIN_HX = CANVAS_W * 0.5,
        MAX_HX = CANVAS_W - HOOP_W - 40;
      const MIN_HY = 60,
        MAX_HY = CANVAS_H * 0.6;
      function moveHoop() {
        hoopX =
          MIN_HX +
          Math.random() * (MAX_HX - MIN_HX);
        hoopY =
          MIN_HY +
          Math.random() * (MAX_HY - MIN_HY);
      }

      // --- DRAW HELPERS ---
      function drawBackground() {
        // ground
        const g = ctx.createLinearGradient(
          0,
          CANVAS_H - 20,
          0,
          CANVAS_H
        );
        g.addColorStop(0, '#cd853f');
        g.addColorStop(1, '#8b4513');
        ctx.fillStyle = g;
        ctx.fillRect(
          0,
          CANVAS_H - 20,
          CANVAS_W,
          20
        );
      }
      function drawBall() {
        ctx.beginPath();
        ctx.arc(
          ball.x,
          ball.y,
          BALL_RADIUS,
          0,
          Math.PI * 2
        );
        ctx.fillStyle = ball.color;
        ctx.fill();
        ctx.stroke();
      }
      function drawHoop() {
        // backboard
        ctx.fillStyle = '#f5f5f5';
        ctx.fillRect(
          hoopX,
          hoopY - BACKBOARD_H / 2,
          BACKBOARD_W,
          BACKBOARD_H
        );
        // rim
        ctx.fillStyle = '#ff4500';
        ctx.fillRect(
          hoopX - HOOP_W,
          hoopY - HOOP_TH / 2,
          HOOP_W,
          HOOP_TH
        );
      }
      function drawTrail() {
        trail.forEach((p, i) => {
          ctx.beginPath();
          const r =
            BALL_RADIUS * (i / trail.length) * 0.6 +
            1;
          ctx.arc(p.x, p.y, r, 0, 2 * Math.PI);
          ctx.fillStyle = `rgba(255,165,0,${p.a *
            0.6})`;
          ctx.fill();
        });
      }
      function drawVelocityArrows() {
        ctx.strokeStyle = 'blue';
        arrowPoints.forEach((pt) => {
          const scale = 5;
          const vx = pt.vx * scale,
            vy = pt.vy * scale;
          ctx.beginPath();
          ctx.moveTo(pt.x, pt.y);
          ctx.lineTo(pt.x + vx, pt.y + vy);
          // arrowhead
          const ang = Math.atan2(vy, vx);
          const headLen = 4;
          ctx.lineTo(
            pt.x + vx -
              headLen * Math.cos(ang - 0.4),
            pt.y + vy -
              headLen * Math.sin(ang - 0.4)
          );
          ctx.moveTo(pt.x + vx, pt.y + vy);
          ctx.lineTo(
            pt.x + vx -
              headLen * Math.cos(ang + 0.4),
            pt.y + vy -
              headLen * Math.sin(ang + 0.4)
          );
          ctx.stroke();
        });
      }

      // --- DYNAMIC EQUATION ---
      function updateDynamicEquation() {
        const vx0 = parseFloat(vxInput.value),
          vy0 = parseFloat(vyInput.value);
        if (isNaN(vx0) || isNaN(vy0)) {
          dynEq.textContent = 'Invalid';
          return;
        }
        const g = getG();
        if (Math.abs(vx0) < 0.01) {
          dynEq.textContent = `x = ${START_X}`;
        } else {
          const A = 0.5 * g / (vx0 * vx0);
          const B = -vy0 / vx0;
          dynEq.innerHTML = `<code>
            y = ${A.toFixed(4)}(x–${START_X})² ${
            B >= 0 ? '+' : '-'
          } ${Math.abs(B).toFixed(3)}(x–${
            START_X
          }) + ${START_Y}
          </code>`;
        }
      }

      // --- TRAJECTORY PREVIEW + VECTORS ---
      function drawTrajectoryPreview() {
        const vx0 = parseFloat(vxInput.value),
          vy0 = parseFloat(vyInput.value);
        if (isNaN(vx0) || isNaN(vy0)) return;
        const g = getG();
        let simX = START_X,
          simY = START_Y;
        let simVx = vx0,
          simVy = -vy0;
        arrowPoints = [];
        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(0,0,255,0.5)';
        ctx.setLineDash([4, 4]);
        ctx.moveTo(simX, simY);
        for (let i = 0; i < 200; i++) {
          simVy += g;
          simX += simVx;
          simY += simVy;
          ctx.lineTo(simX, simY);
          if (i % 20 === 0) {
            arrowPoints.push({
              x: simX,
              y: simY,
              vx: simVx,
              vy: simVy
            });
          }
          if (simY > CANVAS_H) break;
        }
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
        drawVelocityArrows();
      }

      // --- CONFETTI ---
      function launchConfetti() {
        for (let i = 0; i < 100; i++) {
          confetti.push({
            x: hoopX,
            y: hoopY,
            vx: (Math.random() - 0.5) * 4,
            vy: -Math.random() * 4 - 2,
            size: Math.random() * 4 + 2,
            color: `hsl(${Math.random() *
              360},90%,60%)`,
            life: 60
          });
        }
      }
      function updateDrawConfetti() {
        cctx.clearRect(
          0,
          0,
          CANVAS_W,
          CANVAS_H
        );
        confetti = confetti.filter((p) => p.life > 0);
        confetti.forEach((p) => {
          p.life--;
          p.vy += 0.1; // gravity
          p.x += p.vx;
          p.y += p.vy;
          cctx.fillStyle = p.color;
          cctx.fillRect(p.x, p.y, p.size, p.size);
        });
      }

      // --- MAIN DRAW ---
      function drawGame() {
        ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
        drawBackground();
        drawHoop();
        if (!isShooting) {
          updateDynamicEquation();
          drawTrajectoryPreview();
        }
        drawTrail();
        drawBall();
      }

      // --- PHYSICS UPDATE ---
      function updatePhysics() {
        if (!isShooting) return false;
        const prevX = ball.x,
          prevY = ball.y;
        const g = getG();
        ball.vy += g;
        ball.x += ball.vx;
        ball.y += ball.vy;
        trail.push({
          x: ball.x,
          y: ball.y,
          a: 1
        });
        if (trail.length > MAX_TRAIL)
          trail.shift();

        //roof 
        if (ball.y - BALL_RADIUS < 0) {
          endShot(false);
          return true;
        }
        // ground
        if (
          ball.y + BALL_RADIUS >
          CANVAS_H - 20
        ) {
          endShot(false);
          return true;
        }
        // backboard bounce
        const bbL = hoopX,
          bbT = hoopY - BACKBOARD_H / 2,
          bbB = hoopY + BACKBOARD_H / 2,
          bbR = hoopX + BACKBOARD_W;
        if (
          ball.x + BALL_RADIUS > bbL &&
          ball.x - BALL_RADIUS < bbR &&
          ball.y > bbT &&
          ball.y < bbB &&
          ball.vx > 0 &&
          prevX <= bbL
        ) {
          ball.x = bbL - BALL_RADIUS;
          ball.vx *= -BOUNCE_X;
          ball.vy *= BOUNCE_Y;
        }
        // score
        const rimL = hoopX - HOOP_W,
          rimR = hoopX,
          rimY = hoopY;
        if (
          !justScored &&
          ball.x > rimL &&
          ball.x < rimR &&
          prevY < rimY &&
          ball.y >= rimY &&
          ball.vy > 0
        ) {
          endShot(true);
          return true;
        }
        return false;
      }

      function gameLoop() {
        if (isShooting) {
          const done = updatePhysics();
          if (!done) {
            drawGame();
            updateDrawConfetti();
            animId = requestAnimationFrame(gameLoop);
          }
        } else {
          drawGame();
          updateDrawConfetti();
        }
      }

      // --- SHOT CONTROL ---
      function shootBall() {
        if (isShooting) return;
        const vx0 = parseFloat(vxInput.value),
          vy0 = parseFloat(vyInput.value);
        if (isNaN(vx0) || isNaN(vy0)) {
          alert('Enter valid vx₀, vy₀');
          return;
        }
        isShooting = true;
        justScored = false;
        trail = [];
        arrowPoints = [];
        ball.vx = vx0;
        ball.vy = -vy0;
        shootBtn.disabled = true;
        vxInput.disabled = true;
        vyInput.disabled = true;
        animId = requestAnimationFrame(gameLoop);
      }
      shootBtn.addEventListener('click', shootBall);

      function endShot(scored) {
        isShooting = false;
        moveHoop();
        shootBtn.disabled = false;
        vxInput.disabled = false;
        vyInput.disabled = false;
        if (scored) {
          score++;
          if (score > highScore) {
            highScore = score;
            localStorage.setItem(
              'physicsHoopsHighScore',
              highScore
            );
          }
          scoreEl.textContent = `Score: ${score} | High: ${highScore}`;
          msgEl.textContent = 'SWISH!';
          msgEl.style.display = 'block';
          swishSnd.play();
          launchConfetti();
        } else {
          score = 0;
          scoreEl.textContent = `Score: 0 | High: ${highScore}`;
          msgEl.textContent = 'MISS!';
          msgEl.style.display = 'block';
          missSnd.play();
        }
        setTimeout(() => {
          msgEl.style.display = 'none';
        }, 1200);
      }

      // --- GUESS CHECKER ---
      checkGuessBtn.addEventListener('click', () => {
        const A = parseFloat(guessA.value),
          B = parseFloat(guessB.value),
          vx0 = parseFloat(vxInput.value),
          vy0 = parseFloat(vyInput.value);
        if (isNaN(A) || isNaN(B)) {
          alert('Enter numeric A & B');
          return;
        }
        const g = getG();
        const Atrue = (0.5 * g) / (vx0 * vx0);
        const Btrue = -vy0 / vx0;
        const tolA = Math.abs(A - Atrue) < 0.005;
        const tolB = Math.abs(B - Btrue) < 0.01;
        if (tolA && tolB) {
          alert('Correct! 🎉');
        } else {
          alert(
            `Off:\nA true ≈ ${Atrue.toFixed(
              4
            )}\nB true ≈ ${Btrue.toFixed(3)}`
          );
        }
      });

      // --- INIT ---
      moveHoop();
      drawGame();
      scoreEl.textContent = `Score: ${score} | High: ${highScore}`;
    </script>
  </body>
</html>
